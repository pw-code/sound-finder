;
; Implements reading of OV7670 video. One line at a time.
;

.program ov7670

;defines that we will later assert (in video.c) are the same as in pins.h
.define public pio_href_pin  13
.define public pio_vsync_pin 14
.define public pio_pclk_pin  15


.wrap_target
    wait 1 GPIO pio_vsync_pin   ; wait for vsync
    set y, 0                    ; row
    
wait_line:                      ; count hsync lines
    wait 1 GPIO pio_href_pin

    in y, 16                    ; first 16 bits of each row are the row number
    push

    ; we want to read 320 pixels, but only have 1 byte
    ; so we read 160 Pairs of pixels instead

    ; cannot set x directly, so abuse the ISR to buffer 2 nibbles (160 == 0x9F)
    set x, 0x09
    in x, 8
    set x, 0x0F
    in x, 8
    mov x, isr

    ; X is now 159, ISR is empty

pixel_read_160:

    ; Get a pixel (16 bits)
    wait 1 GPIO pio_pclk_pin
    in pins, 8                  ; 8 parallel pin bits
    wait 0 GPIO pio_pclk_pin    ; wait for end of pixel
    wait 1 GPIO pio_pclk_pin
    in pins, 8                  ; 8 parallel pin bits
    wait 0 GPIO pio_pclk_pin    ; wait for end of pixel
    push

    ; Get a pixel (16 bits)
    wait 1 GPIO pio_pclk_pin
    in pins, 8                  ; 8 parallel pin bits
    wait 0 GPIO pio_pclk_pin    ; wait for end of pixel
    wait 1 GPIO pio_pclk_pin
    in pins, 8                  ; 8 parallel pin bits
    wait 0 GPIO pio_pclk_pin    ; wait for end of pixel
    push

    jmp x-- pixel_read_160      ; read 2x160 = 320 pixels

    ; end of row
    ; we are counting UP the row, and want to stop and reset at 230
    ; cannot set x directly, so abuse the ISR to buffer 2 nibbles (239 == 0xEF)
    set x, 0x0E
    in x, 8
    set x, 0x0F
    in x, 8
    mov x, isr

    jmp x!=y wait_line          ; next line in frame

.wrap


% c-sdk {
#include "hardware/clocks.h"

// Which state machine for which function?
const int sm_ov7670 = 0;

static inline void ov7670_program_load(PIO pio, uint pin_pclk, uint pin_data_base) {

    uint offset = pio_add_program(pio, &ov7670_program);
    pio_sm_config cfg = ov7670_program_get_default_config(offset);

    //OV7670 datasheet says typical speed is 24MHz for input clock
    //We are running XCLK at the correct rate, but we need the state machine faster to catch clock edges properly
    //So we have no divider
    sm_config_set_clkdiv(&cfg, 1);

    sm_config_set_in_pins(&cfg, pin_data_base);
    sm_config_set_jmp_pin(&cfg, pin_pclk);

    // Set the pin's GPIO function (connect PIO to the pad)
    pio_gpio_init(pio, pin_pclk);
    for (uint i=0; i<8; ++i) {
        pio_gpio_init(pio, pin_data_base+i);
    }

    // Word size and MSB/LSB
    sm_config_set_in_shift(&cfg,
            false,  // Shift-to-right = false (i.e. shift to left, aka. MSB first)
            false,  // autopush off: we need to abuse the ISR for math!
            16);    // bits per sample

    // Configure and start
    pio_sm_init(pio, sm_ov7670, offset, &cfg);
    pio_sm_clear_fifos(pio, sm_ov7670);
    pio_sm_set_enabled(pio, sm_ov7670, true);
}

%}
