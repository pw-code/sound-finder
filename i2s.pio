;
; Implements 6 I2S inputs using PIO across 3 data lines and shared clock and WS
;
; INMP441 MEMS microphone, 24bits.
; Aim for WS freq 44kHZ (max is 50kHz)
;         SCK freq 2116.8kHz, 2.1MHz (44kHz * 24bits * 2 channels) (max is 3.2MHz)
;
; We are receiving 6x 24bits of data (but in alternate 3x 24bit channels)
; So output data as 3x 8 bit blocks, with the high byte encoding the packet type.
; Type contains left/right channel marker (C) (0 left, 1 right), byte count (B) (0..2 to indicate which of the 24 bits this byte is)
; The remaining 3 bytes are 8bits each from each channel (0,1,2), interleaved as we read them. CPU will have to unpack these.
;   MSG                             LSB
;   xxxxxCBB 01201201 20120120 12012012
;
; We use one whole GPIO
;   * One state machine manages the i2s clocks (CLK & WS)
;   * The other 3 all handle one i2s data bus
;


; This state machine just generates the clock pulses common to all i2s slaves
; -----------------
.program i2s_clocks
.side_set 1

.wrap_target

    //WS = 0
left_word:
    set x, 31           side 0       ;32 clocks per word required by INMP441
left_bits:
    set pins, 0         side 1       ;WS=0, CLK=1
    jmp x-- left_bits   side 0       ;CLK=0, jmp

    set pins, 1         side 0       ;prepare for next word.

    //WS = 1
right_word:
    set x, 31           side 0       ;32 clocks per word required by INMP441
right_bits:
    set pins, 1         side 1       ;WS=1, CLK=1
    jmp x-- right_bits  side 0       ;CLK=0, jmp

    set pins, 0         side 0       ;prepare for next word.

.wrap


; This reads in bits of actual i2s data (one state machine instance per bus)
; -----------------
.program i2s_data
.side_set 1 opt

    set y, 0                   [1]   ;WS substitute - to match ws state in i2s clocks prog - plus 1 cycle delay
                                     ;No matching instruction in clock prog.
                                     ;Because we want to sample on second clock (1 clock cycle behind is2 clocks, see INMP441 datasheet)

.wrap_target

    set x, 30                        ;32 bits per word, but last handled differently
read_bits:
    in  pins, 1         side 1       ;side pins used for debugging only (high when we sample - to check in sync with clock)
    jmp x-- read_bits   side 0

    ; bit 32 (in 2 instructions to match loop size)
    in y, 1             side 1       ;last bit is now WS indicator
    push                side 0       ;non blocking (we must not get out of sync with clocks).

    ; prepare for next work
    mov y, !y               ; flip Y (toggle channel)

.wrap


% c-sdk {
#include "hardware/clocks.h"

// Which state machine for which function?
const int sm_data0 = 0;
const int sm_data1 = 1;
const int sm_data2 = 2;
const int sm_clocks = 3;


static inline void i2s_program_load(PIO pio, uint sample_rate_hz, uint pin_clk, uint pin_ws, uint pin_data0, uint pin_data1, uint pin_data2, uint test_pin) {

    //Inputs must be consecutive pins
    assert(pin_data1 == pin_data0 + 1);
    assert(pin_data2 == pin_data0 + 2);

    //clock control program
    uint clocks_offset = pio_add_program(pio, &i2s_clocks_program);
    pio_sm_config cfg_clocks = i2s_clocks_program_get_default_config(clocks_offset);

    //shared data read program
    uint data_offset = pio_add_program(pio, &i2s_data_program);
    pio_sm_config cfg_data0 = i2s_data_program_get_default_config(data_offset);
    pio_sm_config cfg_data1 = i2s_data_program_get_default_config(data_offset);
    pio_sm_config cfg_data2 = i2s_data_program_get_default_config(data_offset);

    // IO mapping:
    // clock prog sets WS and side-sets CLK
    sm_config_set_set_pins(&cfg_clocks, pin_ws, 1);
    sm_config_set_sideset_pins(&cfg_clocks, pin_clk);
    // data prog just reads data 
    sm_config_set_in_pins(&cfg_data0, pin_data0);
    sm_config_set_in_pins(&cfg_data1, pin_data1);
    sm_config_set_in_pins(&cfg_data2, pin_data2);
    sm_config_set_sideset_pins(&cfg_data0, test_pin);  //DEBUG capture timing

    // Set this pin's GPIO function (connect PIO to the pad)
    pio_gpio_init(pio, pin_clk);
    pio_gpio_init(pio, pin_ws);
    pio_gpio_init(pio, pin_data0);
    pio_gpio_init(pio, pin_data1);
    pio_gpio_init(pio, pin_data2);
    pio_gpio_init(pio, test_pin);

    // Set the pin directions - clk and ws are output, start low
    const uint32_t out_pins_mask = (1u<<pin_clk) | (1u << pin_ws) | (1u << test_pin);
    pio_sm_set_pins_with_mask(pio, sm_clocks, 0, out_pins_mask);
    pio_sm_set_pindirs_with_mask(pio, sm_clocks, -1, out_pins_mask);

    // Word size and MSB/LSB
    sm_config_set_in_shift(&cfg_data0,
            false,  // Shift-to-right = false (i.e. shift to left, aka. MSB first)
            false,  // autopush: false
            32);     // bits: n/a, not auto
    sm_config_set_in_shift(&cfg_data1,
            false,  // Shift-to-right = false (i.e. shift to left, aka. MSB first)
            false,  // autopush: false
            32);     // bits: n/a, not auto
    sm_config_set_in_shift(&cfg_data2,
            false,  // Shift-to-right = false (i.e. shift to left, aka. MSB first)
            false,  // autopush: false
            32);     // bits: n/a, not auto

    // We only receive, so disable the TX FIFO to make the RX FIFO deeper.
//    sm_config_set_fifo_join(&cfg_data0, PIO_FIFO_JOIN_RX);
//    sm_config_set_fifo_join(&cfg_data1, PIO_FIFO_JOIN_RX);
//    sm_config_set_fifo_join(&cfg_data2, PIO_FIFO_JOIN_RX);

    //2.1MHz clock (TODO: needs to be faster because we have multiple PIO instructions per I2S SLK ?)
    const int nbits = 32;
    const uint i2s_rate_hz = sample_rate_hz * 2 * nbits; // 2 channels, 32bits each
    const float pio_cycles_per_i2s_clock = (float)((nbits*2) + 2) / 32.0; //overage the total instructions over the 24bits cycle (loop,set/mov)
    const float div = (float)clock_get_hz(clk_sys) / (i2s_rate_hz * pio_cycles_per_i2s_clock);
    //all the same
    sm_config_set_clkdiv(&cfg_clocks, div);
    sm_config_set_clkdiv(&cfg_data0,  div);
    sm_config_set_clkdiv(&cfg_data1,  div);
    sm_config_set_clkdiv(&cfg_data2,  div);

    // Configure and start all 4 state machines **at the same time** (so they are in sync)
    pio_sm_init(pio, sm_data0,  data_offset,   &cfg_data0 );
    pio_sm_init(pio, sm_data1,  data_offset,   &cfg_data1 );
    pio_sm_init(pio, sm_data2,  data_offset,   &cfg_data2 );
    pio_sm_init(pio, sm_clocks, clocks_offset, &cfg_clocks);

    // set all enabled
    //started in main() after DMA setup 
    //pio_enable_sm_mask_in_sync(pio, 0x0f); //all 4 at once!!
}

%}
